"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6292],{5693:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>n,toc:()=>h});const n=JSON.parse('{"id":"guides/the-transmuter-elaborated","title":"\u2696\ufe0f The Transmuter, Elaborated","description":"A deeper dive into how the Transmuter functions","source":"@site/docs/user/guides/the-transmuter-elaborated.md","sourceDirName":"guides","slug":"/guides/the-transmuter-elaborated","permalink":"/alchemix-v3-docs/user/guides/the-transmuter-elaborated","draft":false,"unlisted":false,"editUrl":"https://github.com/keenanlukeom/alchemix-v3-docs/edit/main/docs/user/docs/user/guides/the-transmuter-elaborated.md","tags":[],"version":"current","frontMatter":{"description":"A deeper dive into how the Transmuter functions","cover":"../../.gitbook/assets/header_02_test.png","coverY":0,"layout":{"cover":{"visible":true,"size":"hero"},"title":{"visible":true},"description":{"visible":true},"tableOfContents":{"visible":true},"outline":{"visible":true},"pagination":{"visible":true}}},"sidebar":"tutorialSidebar","previous":{"title":"\u2697\ufe0f The AMO: The Elixir","permalink":"/alchemix-v3-docs/user/guides/the-amo-the-elixir"},"next":{"title":"\ud83c\udfe6 Vault Losses and Collateral De-pegging","permalink":"/alchemix-v3-docs/user/guides/vault-losses-and-collateral-de-pegging"}}');var r=a(4848),s=a(8453);const i={description:"A deeper dive into how the Transmuter functions",cover:"../../.gitbook/assets/header_02_test.png",coverY:0,layout:{cover:{visible:!0,size:"hero"},title:{visible:!0},description:{visible:!0},tableOfContents:{visible:!0},outline:{visible:!0},pagination:{visible:!0}}},o="\u2696\ufe0f The Transmuter, Elaborated",l={},h=[{value:"Transmuter Flowchart",id:"transmuter-flowchart",level:3},{value:"Flow Rate <a></a>",id:"flow-rate-",level:3}];function d(e){const t={code:"code",h1:"h1",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"\ufe0f-the-transmuter-elaborated",children:"\u2696\ufe0f The Transmuter, Elaborated"})}),"\n",(0,r.jsx)(t.p,{children:"The Transmuter is actually composed of two separate components: The TransmuterBuffer and the Transmuter."}),"\n",(0,r.jsx)(t.p,{children:"When funds enter the Transmuter, assuming there is at least a matching amount of the corresponding alAsset they will be immediately be claimable by users with alAssets staked in the Transmuter. The TransmuterBuffer sits between the Alchemist and Transmuter, limiting the available funds that are accessible for transmutation. The goal here is to delay the transmutability of funds so that the massive front-stop (ie, excess funds in the Transmuter buffer) cannot immediately be used to take advantage of extremely small (< 0.1%) arbitrage opportunities, thus burning protocol value for tiny gains. The longer the system can hold onto the front-stop, the longer it can supply liquidity and earn revenue through the Elixir/AMO, and the more Alchemist depositors Alchemix can sustain."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://alchemix-finance.gitbook.io/~gitbook/image?url=https:%2F%2Flh3.googleusercontent.com%2Fit5PpNg2lG56uV9LcAvPh0OEvw2OdMeUVGHdneY3wdUjEbNLZu7gM-pi7V_KmWu7o2nVPVzAW_-rpkAVVFRA0IyS1Ay_OLLxdK05j912-351_ArmzMqSJ4nsZVU-T0Lb6EauXS8XXoUNUchlbnK6fQ&width=768&dpr=4&quality=100&sign=e28ffadf2207873e8257a61726653775ca96eaed632c949fa00066dbd070ec1c",alt:""})}),"\n",(0,r.jsx)(t.h3,{id:"transmuter-flowchart",children:"Transmuter Flowchart"}),"\n",(0,r.jsxs)(t.p,{children:["In the Transmuter, user-exchanged and un-exchanged balances are updated in a stepwise manner, only when the exchange() function is called. The ",(0,r.jsx)(t.code,{children:"exchange()"})," function sends the underlying asset (USDC, DAI, or USDT) to the Transmuter in exchange for the alUSD burned from the transmuter. The TransmuterBuffer receives a call to its ",(0,r.jsx)(t.code,{children:"exchange()"})," function whenever ",(0,r.jsx)(t.code,{children:"alchemist.harvest()"}),", ",(0,r.jsx)(t.code,{children:"alchemist.liquidate()"}),", or ",(0,r.jsx)(t.code,{children:"alchemist.repay()"})," are called - ie, whenever a yield harvest occurs, or when a user liquidates or repays their loan. ",(0,r.jsx)(t.code,{children:"TransmuterBuffer.exchange()"})," will update the available amount of flow that is theoretically accessible by the transmuter, and subsequently call ",(0,r.jsx)(t.code,{children:"Transmuter.exchange()"})," with the marginal amount of funds that need to be exchanged. Each Transmuter handles a single collateral type. Each TransmuterBuffer handles a single synthetic type, and all collateral types underlying that synthetic."]}),"\n",(0,r.jsxs)(t.h3,{id:"flow-rate-",children:["Flow Rate ",(0,r.jsx)("a",{href:"#flow-rate",id:"flow-rate"})]}),"\n",(0,r.jsx)(t.p,{children:"The flow rate is set by governance and is a per-second MAXIMUM rate of flow for funds to be sent from the TransmuterBuffer to the Transmuter. The main features of the flow are:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Flow-rate is constant and linear."}),"\n",(0,r.jsx)(t.li,{children:"The flow-rate (measured in underlying collateral token per one second, ie 1 DAI/second) will continuously add to the available-flow (measured in the underlying collateral token, ie 1 DAI)."}),"\n",(0,r.jsxs)(t.li,{children:["The available-flow is a measure of how much underlying collateral will immediately flow from the TransmuterBuffer to the Transmuter, upon a deposit to the TransmuterBuffer (ie, a call of the ",(0,r.jsx)(t.code,{children:"exchange()"})," function). This means the available-flow can build up over time if the Transmuter flow-rate is being underutilized. A build-up of available flow makes it possible for the effective flow-rate over a period of time to exceed the flow-rate, thus ensuring the set flow-rate is acting as more of an average over time, rather than a hard cap."]}),"\n",(0,r.jsxs)(t.li,{children:["Each underlying-token has its own flow-rate. The available-flow for a given underlying-token can exceed the total amount of funds denominated in that underlying-token (across all strategies) held by the transmuter-buffer in the Alchemist. However, when this is the case, the Transmuter will only be able to access the actual funds held by the Transmuter-buffer in the Alchemist (see Invariants 1 and 2)","\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Figure 1 shows a scenario where available flow has exceeded the total buffered amount (total amount of underlying token controlled by the Transmuter buffer across all strategies in the alchemist)."}),"\n",(0,r.jsx)(t.li,{children:"Figure 2 shows a scenario where the total buffered amount has exceeded the available flow."}),"\n",(0,r.jsx)(t.li,{children:"In both scenarios, the total amount exchanged to the Transmuter cannot surpass the lesser of the two values in question."}),"\n",(0,r.jsx)(t.li,{children:"In Figure 1, there will be an excess of available-flow. Should the flow of the underlying asset to the Transmuter increase beyond the defined flow-rate, the excess of available-flow would be used to absorb the faster rate (as described in Item 2 above)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://alchemix-finance.gitbook.io/~gitbook/image?url=https:%2F%2Flh5.googleusercontent.com%2FftZLKfzFyYJuB3s1EQyTGQP7oZsqJsTMNxfy8NsOwE9SIUlujL5Una48PwBVAMx5ydcngdoeRn0Nhdfghj5IH-_P-G9fRaR83OLNsY-sIoEYEJyEl34aso1J1h3inyJ5yKNLcLTvtQSttit-6Y7ZmA&width=768&dpr=4&quality=100&sign=89dce485d70a6a1c338e83b640f8ef2ddd09d2f55a21e8166d5c4db6aca4b788",alt:""})}),"\n",(0,r.jsx)(t.p,{children:"Visualization of Transmuter Buffer Available Flow Scenarios"}),"\n",(0,r.jsx)("figure",{children:(0,r.jsx)("img",{src:"../../.gitbook/assets/header_02_test.png",alt:""})})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>o});var n=a(6540);const r={},s=n.createContext(r);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);